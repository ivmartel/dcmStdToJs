{"version":3,"file":"app.bundle.js","mappings":"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","sources":["webpack://dcmStdToJs/./src/parser.js","webpack://dcmStdToJs/./src/nema.js","webpack://dcmStdToJs/./src/gui.js","webpack://dcmStdToJs/./src/index.js"],"sourcesContent":["/**\n * DICOM xml parser.\n */\nexport class DicomXMLParser {\n\n  /**\n   * Parse a DICOM standard xml node.\n   *\n   * @param {Node} partNode The main DOM node.\n   * @param {string} origin The origin of the node (optional).\n   * @returns {object} An object containing:\n   *   - name: a lael for the result,\n   *   - origin: the origin of the node,\n   *   - raw: the raw result,\n   *   - data: the adapted result as string.\n   */\n  parseNode(partNode, origin) {\n    // get book node\n    const book = partNode.querySelector('book');\n    if (!book) {\n      throw new Error('No book node.');\n    }\n    // get book label\n    const label = book.getAttribute('label');\n    if (!label) {\n      throw new Error('No book label.');\n    }\n\n    // get version\n    // 'DICOM PS3.5 2020a - ...'\n    const subtitle = book.querySelector('subtitle');\n    if (!subtitle) {\n      throw new Error('No book subtitle.');\n    }\n    const prefix = 'DICOM ' + label;\n    if (!subtitle.innerHTML.startsWith(prefix)) {\n      throw new Error('Missing DICOM standard version prefix.');\n    }\n    const endIndex = subtitle.innerHTML.indexOf('-');\n    const versionStr =\n      subtitle.innerHTML.substring(prefix.length, endIndex).trim();\n    const version = {\n      year: parseInt(versionStr.substring(0, 4), 10),\n      letter: versionStr.substring(4)\n    };\n\n\n    let result = null;\n\n    if (label === 'PS3.3') {\n      result = parsePs33Node(partNode, origin);\n    } else if (label === 'PS3.5') {\n      result = parsePs35Node(partNode, origin, version);\n    } else if (label === 'PS3.6') {\n      result = parsePs36Node(partNode, origin);\n    } else if (label === 'PS3.7') {\n      result = parsePs37Node(partNode, origin);\n    } else {\n      throw new Error('Unknown book label: ' + label);\n    }\n\n    return result;\n  }\n}\n\n/**\n * Parse a PS3.3 node: Information Object Definitions (IODs).\n * See: {@link https://dicom.nema.org/medical/dicom/current/output/chtml/part03/PS3.3.html}.\n *\n * @param {Node} partNode The main DOM node.\n * @param {string} origin The origin of the node (optional).\n * @returns {object} A result object {name, origin, raw, data}.\n */\nfunction parsePs33Node(partNode, origin) {\n  const result = [];\n  // CT: https://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_A.3.3.html#table_A.3-1\n  const iodList = [\n    {name: 'CT Image', label: 'table_A.3-1'},\n    {name: 'MR Image', label: 'table_A.4-1'},\n    // {name: 'NM Image', label: 'table_A.5-1'},\n    // {name: 'US Image', label: 'table_A.6-1'},\n    // {name: 'PET Image', label: 'table_A.21.3-1'},\n    // {\n    //   name: 'Segmentation',\n    //   label: 'table_A.51-1',\n    //   fgLabel: 'table_A.51-2'\n    // }\n  ];\n\n  for (const iod of iodList) {\n    const usageRegex = /M|C/g;\n    let fgModulesProperties = null;\n    // functional group modules\n    if (typeof iod.fgLabel !== 'undefined') {\n      const fgModulesDefs = parseModuleListNode(\n        partNode.querySelector(getSelector(iod.fgLabel)),\n        partNode,\n        iod.name + ' Functional Group Macros',\n        usageRegex\n      );\n      fgModulesProperties =\n        parseModulesFromList(fgModulesDefs, partNode);\n    }\n    // IOD modules\n    const iodModulesDefs = parseModuleListNode(\n      partNode.querySelector(getSelector(iod.label)),\n      partNode,\n      iod.name + ' IOD Modules',\n      usageRegex\n    );\n    const modulesProperties = parseModulesFromList(\n      iodModulesDefs, partNode, fgModulesProperties);\n\n    const typeRegex = /1|1C/g;\n    const modules = modulePropertiesListToObject(\n      modulesProperties, typeRegex);\n\n    result.push({\n      name: iod.name + ' IOD Modules',\n      origin: origin,\n      raw: modules,\n      data: JSON.stringify(modules, null, '  ')\n    });\n  }\n  return result;\n}\n\n/**\n * Parse a PS3.5 node: Data Structures and Encoding.\n * See: {@link https://dicom.nema.org/medical/dicom/current/output/chtml/part05/PS3.5.html}.\n *\n * @param {Node} partNode The main DOM node.\n * @param {string} origin The origin of the node (optional).\n * @param {object} version The version of the standard.\n * @returns {object} A result object {name, origin, raw, data}.\n */\nfunction parsePs35Node(partNode, origin, version) {\n  // VRs\n  // https://dicom.nema.org/medical/dicom/current/output/chtml/part05/sect_6.2.html#table_6.2-1\n  const vrs = parseVrTableNode(\n    partNode.querySelector(getSelector('table_6.2-1')),\n    'DICOM Value Representations');\n\n  const vrsNames = Object.keys(vrs);\n\n  // replace undefined with null for JSON\n  for (let i = 0; i < vrsNames.length; ++i) {\n    if (typeof vrs[vrsNames[i]] === 'undefined') {\n      vrs[vrsNames[i]] = null;\n    }\n  }\n\n  const vrsResult = {\n    name: 'VRs',\n    origin: origin,\n    raw: vrs,\n    data: JSON.stringify(vrs, null, '  ')\n  };\n\n  // 32-bit VL VRs\n  // https://dicom.nema.org/medical/dicom/current/output/chtml/part05/chapter_7.html#table_7.1-1\n  // table 7.1-1 caption:\n  // - before 2019e: 'Data Element with Explicit VR of OB, OD...'\n  // - >= 2019e: 'Data Element with Explicit VR other than as shown\n  //   in Table 7.1-2'\n  let isBefore2019e = true;\n  if (version.year > 2019 ||\n    (version.year === 2019 && version.letter >= 'e')) {\n    isBefore2019e = false;\n  }\n\n  let xmlid = 'table_7.1-2';\n  if (isBefore2019e) {\n    xmlid = 'table_7.1-1';\n  }\n  const specialVrs = parseVrCaptionNode(\n    partNode.querySelector(getSelector(xmlid)),\n    'Data Element with Explicit VR');\n\n  let vrVl32s = specialVrs;\n  if (!isBefore2019e) {\n    vrVl32s = vrsNames.filter(function (item) {\n      return !specialVrs.includes(item);\n    });\n  }\n\n  const vrVl32Result = {\n    name: '32-bit VL VRs',\n    origin: origin,\n    raw: vrVl32s,\n    data: JSON.stringify(vrVl32s)\n  };\n\n  // Extended or replaced default character repertoire VRs\n  // https://dicom.nema.org/medical/dicom/current/output/html/part05.html#sect_6.1.2.2\n  const charSetVrs = parseCharSetVrNode(\n    partNode.querySelector(getSelector('sect_6.1.2.2')));\n\n  const charSetVrResult = {\n    name: 'Character Set VRs',\n    origin: origin,\n    raw: charSetVrs,\n    data: JSON.stringify(charSetVrs)\n  };\n\n  return [vrsResult, vrVl32Result, charSetVrResult];\n}\n\n/**\n * Parse a PS3.6 node: Data Dictionary.\n * See: {@link https://dicom.nema.org/medical/dicom/current/output/chtml/part06/PS3.6.html}.\n *\n * @param {Node} partNode The main DOM node.\n * @param {string} origin The origin of the node (optional).\n * @returns {object} A result object {name, origin, raw, data}.\n */\nfunction parsePs36Node(partNode, origin) {\n  let tags36 = [];\n  // 0002: DICOM File Meta Elements\n  // https://dicom.nema.org/medical/dicom/current/output/chtml/part06/chapter_7.html#table_7-1\n  tags36 = tags36.concat(parseTagsTableNode(\n    partNode.querySelector(getSelector('table_7-1')),\n    partNode,\n    'Registry of DICOM File Meta Elements'));\n  // 0004: DICOM Directory Structuring Elements\n  // https://dicom.nema.org/medical/dicom/current/output/chtml/part06/chapter_8.html#table_8-1\n  tags36 = tags36.concat(parseTagsTableNode(\n    partNode.querySelector(getSelector('table_8-1')),\n    partNode,\n    'Registry of DICOM Directory Structuring Elements'));\n  // DICOM Data Elements\n  // https://dicom.nema.org/medical/dicom/current/output/chtml/part06/chapter_6.html#table_6-1\n  tags36 = tags36.concat(parseTagsTableNode(\n    partNode.querySelector(getSelector('table_6-1')),\n    partNode,\n    'Registry of DICOM Data Elements'));\n\n  const tagsResults = {\n    name: 'DICOM Tags',\n    origin: origin,\n    raw: tags36,\n    data: stringifyTags(adaptTagsForDwv(tags36))\n  };\n\n  // transfer syntax\n  // https://dicom.nema.org/medical/dicom/current/output/chtml/part06/chapter_A.html#table_A-1\n  const uids = parseUidTableNode(\n    partNode.querySelector(getSelector('table_A-1')),\n    partNode,\n    'UID Values',\n    'Transfer Syntax');\n  const uidsResults = {\n    name: 'Transfer syntax UIDs',\n    origin: origin,\n    raw: uids,\n    data: JSON.stringify(adaptUidsForDwv(uids), null, '  ')\n  };\n\n  // SOPs\n  // https://dicom.nema.org/medical/dicom/current/output/chtml/part06/chapter_A.html#table_A-1\n  const sops = parseUidTableNode(\n    partNode.querySelector(getSelector('table_A-1')),\n    partNode,\n    'UID Values',\n    'SOP');\n  const sopsResults = {\n    name: 'SOP class and instance UIDs',\n    origin: origin,\n    raw: sops,\n    data: JSON.stringify(adaptUidsForDwv(sops), null, '  ')\n  };\n\n  return [tagsResults, uidsResults, sopsResults];\n}\n\n/**\n * Parse a PS3.7 node: Message Exchange.\n * See: {@link https://dicom.nema.org/medical/dicom/current/output/chtml/part07/PS3.7.html}.\n *\n * @param {Node} partNode The main DOM node.\n * @param {string} origin The origin of the node (optional).\n * @returns {object} A result object {name, origin, raw, data}.\n */\nfunction parsePs37Node(partNode, origin) {\n  let tags37 = [];\n  // 0000: command\n  // https://dicom.nema.org/medical/dicom/current/output/chtml/part07/chapter_E.html#table_E.1-1\n  tags37 = tags37.concat(parseTagsTableNode(\n    partNode.querySelector(getSelector('table_E.1-1')),\n    partNode,\n    'Command Fields'));\n  // 0000: command (retired)\n  // https://dicom.nema.org/medical/dicom/current/output/chtml/part07/sect_E.2.html#table_E.2-1\n  tags37 = tags37.concat(parseTagsTableNode(\n    partNode.querySelector(getSelector('table_E.2-1')),\n    partNode,\n    'Retired Command Fields'));\n\n  return {\n    name: 'DICOM tags group 0000',\n    origin: origin,\n    raw: tags37,\n    data: stringifyTags(adaptTagsForDwv(tags37))\n  };\n}\n\n/**\n * Get a selector for an element with the input xml:id.\n * Looking for:\n *   - <table label=\"l\"> when the id starts with 'table_',\n *   - <section label=\"l\"> when the id starts with 'sect_'.\n *\n * @param {string} xmlid The id to look for.\n * @returns {string} The selector.\n */\nfunction getSelector(xmlid) {\n  let prefix = '';\n  if (xmlid.startsWith('table_')) {\n    prefix = 'table[label=\\'' + xmlid.substring(6);\n  } else if (xmlid.startsWith('sect_')) {\n    prefix = 'section[label=\\'' + xmlid.substring(5);\n  } else {\n    throw new Error('Unknown xml:id format.');\n  }\n  return prefix + '\\']';\n}\n\n/**\n * Get the 'linkend' value (an xml:id) of an input string.\n * Looking for: <xref linkend=\"sect_C.1-7\">.\n *\n * @param {string} str The input string.\n * @returns {string} The xml:id.\n */\nfunction getLinkend(str) {\n  const regex = /linkend=\"(.+?)\"/g;\n  const matches = [...str.matchAll(regex)];\n  // return first result\n  if (matches.length === 0 || matches[0].length !== 2) {\n    throw new Error('Cannot find linkend value in: ' + str);\n  }\n  return matches[0][1];\n}\n\n/**\n * Extract enum values from a string\n *   (created by parseVariableListNode).\n *\n * @param {string} str The string to extract the enum from.\n * @returns {object} An object containing the input string ('str')\n *   either in full or without the enum if found and\n *   the enum ('enum') if found.\n */\nfunction extractEnum(str) {\n  const result = {str: str};\n\n  // looks like: 'enum=ITEM0,ITEM1;'\n  const start = str.indexOf('enum=');\n  if (start !== -1) {\n    const end = str.indexOf(';');\n    if (end === -1) {\n      throw new Error('Badly formed enum');\n    }\n    // remove enum from input\n    const desc = str.substring(0, start) +\n      str.substring(end, str.length - 1);\n    result.str = desc.trim();\n    // store enum as array\n    result.enum = str.substring(start + 5, end).split(',');\n  }\n\n  return result;\n}\n\n/**\n * Extract condition arguments from a string.\n *\n * @param {string} str The string to extract the condition from.\n * @returns {object} An object containing the input string ('str')\n *   either in full or without the condition if found and\n *   the condition ('condition') if found.\n */\nfunction extractCondition(str) {\n  const result = {str: str};\n\n  const reqIndex = str.indexOf('Required if');\n  if (reqIndex !== -1) {\n    let gotConditionMatch = false;\n    // 'Required if Context Identifier (0008,010F) is present.'\n    const regex = /Required if ([\\w\\s]+) (\\([\\dA-F]{4},[\\dA-F]{4}\\)) ([\\w\\s]+)\\./g;\n    const matches = [...str.matchAll(regex)];\n    if (matches.length !== 0 && matches[0].length === 4) {\n      if (matches[0][3] === 'is present' ||\n        matches[0][3] === 'is not present' ||\n        matches[0][3].startsWith('has a value') ||\n        matches[0][3].startsWith('is')) {\n        gotConditionMatch = true;\n        // condition without first match element\n        result.condition = matches[0].slice(1);\n        // remove condition from input\n        result.str = str.replace(matches[0][0], '');\n      }\n    }\n\n    if (!gotConditionMatch) {\n      // condition\n      result.condition = str.substring(reqIndex);\n      // console.log('Cannot extract condition from: ', result.condition);\n      // remove condition from input\n      result.str = str.substring(0, reqIndex);\n    }\n  }\n  return result;\n}\n\n/**\n * Get a compare function for a specific object property.\n *\n * @param {string} property The object property to sort by.\n * @returns {Function} A compare function.\n */\nfunction getCompare(property) {\n  return function (a, b) {\n    if (a[property] < b[property]) {\n      return -1;\n    }\n    if (a[property] > b[property]) {\n      return 1;\n    }\n    return 0;\n  };\n}\n\n/**\n * Get a multi compare function for a list of object properties.\n *\n * @param {Array} properties The list of object properties to sort by.\n * @returns {Function} A compare function.\n */\nfunction getMultiCompare(properties) {\n  return function (a, b) {\n    let res = null;\n    for (let i = 0; i < properties.length; ++i) {\n      res = getCompare(properties[i])(a, b);\n      // if result is not zero, exit\n      if (res !== 0) {\n        return res;\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Parse a DICOM standard XML table node.\n *\n * @param {Node} tableNode A DOM table node.\n * @param {Node} partNode The main DOM node.\n * @param {string|undefined} expectedCaption Optional expected table caption.\n * @returns {Array} The table property values.\n */\nfunction parseTableNode(tableNode, partNode, expectedCaption) {\n  // check node\n  if (!tableNode) {\n    throw new Error('No table node.');\n  }\n  // check caption\n  if (typeof expectedCaption !== 'undefined') {\n    checkNodeCaption(tableNode, expectedCaption);\n  }\n  // parse node rows\n  const properties = [];\n  const nodes = tableNode.querySelectorAll('tbody > tr');\n  if (nodes) {\n    for (const node of nodes) {\n      properties.push(parseTrNode(node, partNode));\n    }\n  }\n  return properties;\n}\n\n/**\n * Check a node caption.\n *\n * @param {Node} node A DOM node.\n * @param {string} expectedCaption The expected node caption.\n * @param {boolean} isEqualCheck Bool to perform equal or include\n *   caption text check.\n */\nfunction checkNodeCaption(node, expectedCaption, isEqualCheck) {\n  if (typeof isEqualCheck === 'undefined') {\n    isEqualCheck = true;\n  }\n  const captions = node.getElementsByTagName('caption');\n  if (!captions) {\n    throw new Error('No node caption.');\n  }\n  if (captions.length === 0) {\n    throw new Error('Empty node caption.');\n  }\n  const text = captions[0].innerHTML;\n  if (isEqualCheck) {\n    if (text !== expectedCaption) {\n      if (text.toLowerCase() === expectedCaption.toLowerCase()) {\n        console.warn('Accepting caption with different case: ' +\n          expectedCaption);\n      } else {\n        throw new Error(\n          'The node caption is not the expected one: ' +\n          expectedCaption + ' != ' + text);\n      }\n    }\n  } else {\n    if (!text.includes(expectedCaption)) {\n      throw new Error(\n        'The node caption does not include the expected one: ' +\n        expectedCaption + ' != ' + text);\n    }\n  }\n}\n\n/**\n * Parse a DICOM standard XML table row node.\n *\n * @param {Node} trNode A DOM row node.\n * @param {Node} partNode The main DOm node.\n * @returns {Array} The row property values.\n */\nfunction parseTrNode(trNode, partNode) {\n  const properties = [];\n  const nodes = trNode.querySelectorAll('td');\n  if (nodes) {\n    for (const node of nodes) {\n      properties.push(parseTdNode(node, partNode));\n    }\n  }\n  // return\n  return properties;\n}\n\n/**\n * Parse a DICOM standard XML table row cell node.\n *\n * @param {Node} tdNode A DOM cell node.\n * @param {Node} partNode The main DOM node.\n * @returns {Array} The cell property values.\n */\nfunction parseTdNode(tdNode, partNode) {\n  const properties = [];\n  const nodes = tdNode.childNodes;\n  if (nodes) {\n    for (const node of nodes) {\n      // type 1 (elements) to avoid #text between elements\n      if (node.nodeType === 1) {\n        if (node.nodeName === 'variablelist') {\n          properties.push(parseVariableListNode(node));\n        } else {\n          properties.push(parseContentNode(node, partNode));\n        }\n      }\n    }\n  }\n  // return\n  return properties;\n}\n\n/**\n * Parse a DICOM standard XML table row cell content node,\n * mainly para and note.\n *\n * @param {Node} paraNode A DOM para node.\n * @param {Node} partNode The main DOM node.\n * @returns {string} The para value.\n */\nfunction parseContentNode(paraNode, partNode) {\n  let content = '';\n  const nodes = paraNode.childNodes;\n  if (nodes) {\n    for (const node of nodes) {\n      if (node.nodeType === 1) {\n        // type 1: element\n        if (node.nodeName === 'xref') {\n          // just keep linkend for xref\n          content += 'linkend=\"' + node.attributes.linkend.value + '\"';\n        } else {\n          content += parseContentNode(node, partNode);\n        }\n      } else if (node.nodeType === 3) {\n        // type 3: text\n        content += node.textContent;\n      } else {\n        console.warn('Un-anticipated node:' + node);\n      }\n    }\n  }\n  // clean\n  content = cleanString(content);\n\n  // link to section with defined terms\n  // (for ex in module attributes description)\n  const regex = /See linkend=.+ for Defined Terms\\./g;\n  const match = content.match(regex);\n  if (match && match.length === 1) {\n    let foundTermsList = false;\n    const xmlid = getLinkend(content);\n    if (xmlid.startsWith('sect_')) {\n      const subSection = partNode.querySelector(getSelector(xmlid));\n      const nodes = subSection.childNodes;\n      if (nodes) {\n        for (const node of nodes) {\n          if (node.nodeName === 'variablelist') {\n            if (!foundTermsList) {\n              foundTermsList = true;\n              content = content.replace(match[0], parseVariableListNode(node));\n            } else {\n              console.warn('Multiple variable list for ' + xmlid);\n            }\n          }\n        }\n      }\n    }\n    if (!foundTermsList) {\n      console.warn('Did not find terms list with: ' + content);\n    }\n  }\n\n  // return\n  return content;\n}\n\n/**\n * Parse a DICOM standard XML VariableList node.\n *\n * @param {Node} listNode A DOM list node.\n * @returns {string} The list values.\n */\nfunction parseVariableListNode(listNode) {\n  let content = 'enum=';\n  const listChilds = listNode.childNodes;\n  if (listChilds) {\n    for (const node of listChilds) {\n      if (node.nodeName === 'varlistentry') {\n        const entries = node.childNodes;\n        if (entries) {\n          for (const entryNode of entries) {\n            if (entryNode.nodeName === 'term') {\n              content += cleanString(entryNode.textContent) + ',';\n            }\n          }\n        }\n      }\n    }\n  }\n  // replace last comma with semicolon\n  return content.replace(/,$/, ';');\n}\n\n/**\n * Trim and get rid of new line and zero-width space.\n *\n * @param {string} str The input string.\n * @returns {string} The cleaned string.\n */\nfunction cleanString(str) {\n  return str.trim().replace(/\\n/g, '').replace(/\\u200B/g, '');\n}\n\n/**\n * Parse a DICOM standard XML tags table node.\n *\n * @param {Node} tableNode A DOM table node.\n * @param {Node} partNode The main DOM node.\n * @param {string} expectedCaption The expected node caption.\n * @returns {Array} The list of DICOM tags objects.\n */\nfunction parseTagsTableNode(tableNode, partNode, expectedCaption) {\n  const values = parseTableNode(tableNode, partNode, expectedCaption);\n  const tags = [];\n  let tag = null;\n  for (const value of values) {\n    tag = tagPropertiesToObject(value);\n    if (tag) {\n      tags.push(tag);\n    }\n  }\n  return tags;\n}\n\n/**\n * Parse a DICOM standard XML UIDs table node.\n *\n * @param {Node} tableNode A DOM table node.\n * @param {Node} partNode The main DOM node.\n * @param {string} expectedCaption The expected node caption.\n * @param {string} uidType The UID type.\n * @returns {object} The list of transfer syntax UIDs.\n */\nfunction parseUidTableNode(tableNode, partNode, expectedCaption, uidType) {\n  const values = parseTableNode(tableNode, partNode, expectedCaption);\n  const uids = {};\n  let uid = null;\n  for (const value of values) {\n    uid = uidPropertiesToObject(value, uidType);\n    if (uid) {\n      //uids[uid.value] = uid.name;\n      uids[uid.value] = uid.keyword;\n    }\n  }\n  return uids;\n}\n\n/**\n * Extract a string VR type for a string.\n *\n * @param {string} str Input string.\n * @returns {string|undefined} The type if found or undefined.\n */\nfunction stringVrTypeExtractor(str) {\n  let type;\n  if (str.startsWith('A string of characters') ||\n    str.startsWith('A character string') ||\n    str.startsWith('A concatenated date-time character string')) {\n    type = 'string';\n  }\n  return type;\n}\n\n/**\n * Extract an octet VR type for a string.\n *\n * @param {string} str Input string.\n * @returns {string|undefined} The type if found or undefined.\n */\nfunction octetVrTypeExtractor(str) {\n  let type;\n  // pre 2017 uses string and not stream...\n  if (str.startsWith('An octet-stream') ||\n    str.startsWith('A string of bytes')) {\n    type = 'Uint8';\n  }\n  return type;\n}\n\n/**\n * Extract a integer VR type for a string.\n *\n * @param {string} str Input string.\n * @returns {string|undefined} The type if found or undefined.\n */\nfunction intVrTypeExtractor(str) {\n  let type;\n  const regex = /(Signed|Unsigned) binary integer (\\d{2}) bits long/g;\n  const match = [...str.matchAll(regex)];\n  if (match.length === 1 && match[0].length === 3) {\n    type = match[0][1] === 'Unsigned' ? 'Ui' : 'I';\n    type += 'nt' + match[0][2];\n  }\n  return type;\n}\n\n/**\n * Extract a float VR type for a string.\n *\n * @param {string} str Input string.\n * @returns {string|undefined} The type if found or undefined.\n */\nfunction floatVrTypeExtractor(str) {\n  let type;\n  const regex = /IEEE 754:1985 (\\d{2})-bit Floating Point Number/g;\n  const match = [...str.matchAll(regex)];\n  if (match.length === 1 && match[0].length === 2) {\n    type = 'Float' + match[0][1];\n  }\n  return type;\n}\n\n/**\n * Extract a word VR type for a string.\n *\n * @param {string} str Input string.\n * @returns {string|undefined} The type if found or undefined.\n */\nfunction wordVrTypeExtractor(str) {\n  let type;\n  // pre 2017 uses string and not stream...\n  const regex = /A (?:stream|string) of (\\d{2})-bit words/g;\n  const match = [...str.matchAll(regex)];\n  if (match.length === 1 && match[0].length === 2) {\n    type = 'Uint' + match[0][1];\n  }\n  return type;\n}\n\n/**\n * Extract a flaot word VR type for a string.\n *\n * @param {string} str Input string.\n * @returns {string|undefined} The type if found or undefined.\n */\nfunction floatWordVrTypeExtractor(str) {\n  let type;\n  const regex = /(\\d{2})-bit IEEE 754:1985 floating point words/g;\n  const match = [...str.matchAll(regex)];\n  if (match.length === 1 && match[0].length === 2) {\n    type = 'Uint' + match[0][1];\n  }\n  return type;\n}\n\n/**\n * Parse a VR 32bit VL DICOM standard XML node.\n *\n * @param {Node} tableNode The content node.\n * @param {Node} partNode The main DOM node.\n * @param {string} expectedCaption The expected node caption root.\n * @returns {Array} The list of VRs.\n */\nfunction parseVrTableNode(tableNode, partNode, expectedCaption) {\n  const values = parseTableNode(tableNode, partNode, expectedCaption);\n  const vrs = {};\n\n  const extractors = [\n    stringVrTypeExtractor,\n    octetVrTypeExtractor,\n    intVrTypeExtractor,\n    floatVrTypeExtractor,\n    wordVrTypeExtractor,\n    floatWordVrTypeExtractor\n  ];\n\n  for (const value of values) {\n    // 'short' VR name\n    const vrName = value[0][0];\n    // definition\n    const definition = value[1][0];\n    let type;\n    for (const extractor of extractors) {\n      type = extractor(definition);\n      // exit if found\n      if (typeof type !== 'undefined') {\n        break;\n      }\n    }\n    // log unknown types (typically AT and SQ)\n    if (typeof type === 'undefined') {\n      console.log('Unknown VR type for ' + vrName);\n    }\n    // store\n    vrs[vrName] = type;\n  }\n  return vrs;\n}\n\n/**\n * Parse a module list DICOM standard XML node:\n *   can be an IOD modules list or a functional group macros.\n *\n * @param {Node} node The content node.\n * @param {Node} partNode The main DOM node.\n * @param {string} expectedCaption The expected node caption.\n * @param {string} usageRegex Optional usage selection regex.\n * @returns {Array} The list of IOD modules.\n */\nfunction parseModuleListNode(node, partNode, expectedCaption, usageRegex) {\n  const values = parseTableNode(node, partNode, expectedCaption);\n  const modules = [];\n  let module = null;\n  for (const value of values) {\n    module = moduleDefinitionPropertiesToObject(value, usageRegex);\n    if (module) {\n      modules.push(module);\n    }\n  }\n  return modules;\n}\n\n/**\n * Get modules from a modules definition list.\n *\n * @param {Array} list The IOD module list.\n * @param {Node} partNode The main DOM node.\n * @param {object} fgModulesProperties Optional functional group\n *   modules properties, undefined to parse a functional group.\n * @returns {Array} The modules array.\n */\nfunction parseModulesFromList(list, partNode, fgModulesProperties) {\n  const result = {};\n  for (const item of list) {\n    // TODO include usage and condition\n    const moduleName = item.module;\n    // get the module from the referenced section\n    const xmlid = getLinkend(item.reference);\n    const sectNode = partNode.querySelector(getSelector(xmlid));\n    for (const node of sectNode.childNodes) {\n      // stop at first table\n      if (node.nodeName === 'table') {\n        let name = moduleName;\n        if (typeof fgModulesProperties === 'undefined') {\n          name += ' Macro';\n        } else {\n          name += ' Module';\n        }\n        name += ' Attributes';\n        result[moduleName] =\n          parseModuleAttributesNode(node, partNode, name, fgModulesProperties);\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nconst macros = {};\n\n/**\n * Parse a Information Entities (IE) modules DICOM standard XML node.\n *\n * @param {Node} node The content node.\n * @param {Node} partNode The main DOM node.\n * @param {string} expectedCaption The expected node caption.\n * @param {object} fgModules A list of functional group modules.\n * @returns {Array} The list of ....\n */\nfunction parseModuleAttributesNode(node, partNode, expectedCaption, fgModules) {\n  // expecting macro includes as: 'Include <xref linkend=\"table_10-18\"\n  //   xrefstyle=\"select: label quotedtitle\"/>'\n  const includeMacro = 'Include linkend=';\n  const includeFG = 'Include one or more Functional Group Macros';\n\n  const rows = parseTableNode(node, partNode, expectedCaption);\n  const result = [];\n  let startSq0 = false;\n  let startSq1 = false;\n  for (const row of rows) {\n    if (row.length === 0) {\n      const nodeCaptions = node.getElementsByTagName('caption');\n      if (nodeCaptions && nodeCaptions.length !== 0) {\n        console.warn('Empty module row in: ', nodeCaptions[0].innerHTML);\n      } else {\n        console.warn('Empty module row');\n      }\n      continue;\n    }\n    let attribute;\n    const attributeName = cleanString(row[0][0]);\n    let includeCase = false;\n\n    if (row.length === 4) {\n      // default: Attribute Name, Tag, Type, Attribute Description\n      attribute = [row];\n    } else if (attributeName.includes(includeMacro)) {\n      // include module macro\n      includeCase = true;\n      const xmlid = getLinkend(attributeName);\n      if (xmlid.startsWith('table_')) {\n        // store macro if not done yet\n        if (!macros[xmlid]) {\n          const subTable = partNode.querySelector(getSelector(xmlid));\n          macros[xmlid] =\n            parseModuleAttributesNode(subTable, partNode, undefined);\n        }\n        attribute = macros[xmlid];\n      }\n    } else if (attributeName.includes(includeFG)) {\n      // include functional group macro\n      includeCase = true;\n      attribute = [];\n      const keys = Object.keys(fgModules);\n      for (const key of keys) {\n        attribute = attribute.concat(fgModules[key]);\n      }\n    } else {\n      // avoid these rows\n      // code sequence: BASIC CODED ENTRY ATTRIBUTES, ENHANCED ENCODING MODE\n      if (attributeName !== 'BASIC CODED ENTRY ATTRIBUTES' &&\n        attributeName !== 'ENHANCED ENCODING MODE') {\n        console.warn('Unexpected row: \\'' + attributeName + '\\'');\n      }\n      continue;\n    }\n\n    // handle sequences\n    if (attributeName.startsWith('>')) {\n      // previous attribute (first level)\n      let previousAtt = result[result.length - 1];\n      // set flag and append array for first item\n      if (!startSq0) {\n        previousAtt.push([]);\n        startSq0 = true;\n      }\n      // remove '>' from name\n      if (!includeCase) {\n        attribute[0][0][0] = attribute[0][0][0].substring(1);\n      }\n\n      if (attributeName.startsWith('>>')) {\n        // previous attribute (second level)\n        previousAtt = previousAtt[4][previousAtt[4].length - 1];\n        // set flag and append array for first item\n        if (!startSq1) {\n          previousAtt.push([]);\n          startSq1 = true;\n        }\n      } else {\n        // reset second level flag\n        if (startSq1) {\n          startSq1 = false;\n        }\n      }\n      // append to previous attribute\n      previousAtt[4].push(...attribute);\n    } else if (attributeName.startsWith('>>>')) {\n      console.warn('Not expecting a triple \\'>\\'');\n    } else {\n      // reset first level flag\n      if (startSq0) {\n        startSq0 = false;\n      }\n      // reset second level flag\n      if (startSq1) {\n        startSq1 = false;\n      }\n      // append to result\n      result.push(...attribute);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Parse a VR 32bit VL DICOM standard XML node.\n *\n * @param {Node} node The content node.\n * @param {string} expectedCaptionRoot The expected node caption root.\n * @returns {Array} The list VRs.\n */\nfunction parseVrCaptionNode(node, expectedCaptionRoot) {\n  // check node\n  if (!node) {\n    throw new Error('No Vr caption node.');\n  }\n  // check caption\n  checkNodeCaption(node, expectedCaptionRoot, false);\n  // expecting something like:\n  // 'Data Element with Explicit VR of OB, OW, OF, OD, SQ, UT or UN'\n  const regex = /(?:\\s)([A-Z]{2})(?:,|\\sor|\\sand|$)/g;\n  const caption = node.getElementsByTagName('caption');\n  const text = caption[0].innerHTML;\n  const matches = text.matchAll(regex);\n  const result = [];\n  for (const match of matches) {\n    result.push(match[1]); // [0] includes non capturing groups\n  }\n  return result;\n}\n\n/**\n * Parse a Character Set VR DICOM standard XML node.\n *\n * @param {Node} node The content node.\n * @returns {Array} The list of VRs.\n */\nfunction parseCharSetVrNode(node) {\n  // check node\n  if (!node) {\n    throw new Error('No char Vr node.');\n  }\n\n  const result = [];\n\n  // expecting something like:\n  // For Data Elements with Value Representations of SH (Short String),\n  // LO (Long String), UC (Unlimited Characters), ST (Short Text),\n  // LT (Long Text), UT (Unlimited Text) or PN (Person Name)\n  const regex = /(?:\\s)([A-Z]{2})(?:\\s\\(\\w+\\s\\w+\\))/g;\n  const paras = node.getElementsByTagName('para');\n  for (const para of paras) {\n    if (para.innerHTML.startsWith(\n      'For Data Elements with Value Representations')) {\n      const text = para.innerHTML;\n      const matches = text.matchAll(regex);\n      for (const match of matches) {\n        result.push(match[1]); // [0] includes non capturing groups\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Parse tag values as array and return a tag object.\n *\n * @param {Array} properties A tag row array of properties (length=6).\n * @returns {object} A tag object: {group, element, keyword, vr, vm}.\n */\nfunction tagPropertiesToObject(properties) {\n  // check length (then only use the first element of each item)\n  if (properties.length !== 5 && properties.length !== 6) {\n    throw new Error(\n      'Not the expected tag properties size: ' + properties.length);\n  }\n  // split (group,element)\n  const geSplit = properties[0][0].split(',');\n  const group = geSplit[0].substring(1, 5).toString();\n  const element = geSplit[1].substring(0, 4).toString();\n  // return\n  return {\n    group: group,\n    element: element,\n    keyword: typeof properties[2][0] === 'undefined' ? '' : properties[2][0],\n    vr: typeof properties[3][0] === 'undefined' ? '' : properties[3][0],\n    vm: typeof properties[4][0] === 'undefined' ? '' : properties[4][0]\n  };\n}\n\n/**\n * Parse UID values as array and return a UID object.\n *\n * @param {Array} properties A UID row array of properties (length=6).\n * @param {string} uidType The UID type.\n * @returns {object} A tag object: {group, element, keyword, vr, vm}.\n */\nfunction uidPropertiesToObject(properties, uidType) {\n  // check length (then only use the first element of each item)\n  if (properties.length !== 4 && properties.length !== 5) {\n    throw new Error('Not the expected UID values size: ' + properties.length);\n  }\n  let uid = null;\n  // check UID type\n  // a 'UID keyword' column was added in 2020d, use len-2 instead of index\n  if (properties[properties.length - 2][0].includes(uidType)) {\n    uid = {\n      value: properties[0][0],\n      name: properties[1][0],\n      keyword: properties[2][0]\n    };\n  }\n  return uid;\n}\n\n\n/**\n * Objectify IOD modules properties.\n *\n * @param {Array} properties The IOD module properties.\n * @param {string} usageRegex Optional usage selection regex.\n * @returns {object} A IOD module object.\n */\nfunction moduleDefinitionPropertiesToObject(properties, usageRegex) {\n  // check length (then only use the first element of each item)\n  if (properties.length !== 3 && properties.length !== 4) {\n    throw new Error('Not the expected IOD module values size: ' +\n      properties.length);\n  }\n  // possible Information Entities (IE) extra first column\n  let startCol = 0;\n  if (properties.length === 4) {\n    startCol = 1;\n  }\n  const moduleDef = {\n    module: properties[startCol][0],\n    reference: properties[startCol + 1][0],\n    usage: properties[startCol + 2][0]\n  };\n\n  // get condition from usage\n  if (moduleDef.usage.startsWith('C - Required')) {\n    moduleDef.condition = moduleDef.usage.substring(4);\n    moduleDef.usage = 'C';\n  }\n\n  // Usage property:\n  // - M: Mandatory;\n  // - C: Conditional;\n  // - U: User Option;\n  // https://dicom.nema.org/medical/dicom/current/output/chtml/part03/chapter_A.html#sect_A.1.3\n  if (moduleDef.usage !== 'M' && moduleDef.usage !== 'C' &&\n    moduleDef.usage !== 'U') {\n    console.warn('Unexpected IOD module usage: ' + moduleDef.usage);\n  }\n\n  // usage filter\n  if (typeof usageRegex !== 'undefined' &&\n    moduleDef.usage.match(usageRegex) === null) {\n    return null;\n  }\n\n  return moduleDef;\n}\n\n/**\n * Objectify modules properties.\n *\n * @param {Array} properties The module properties.\n * @param {string} typeRegex Optional type selection regex.\n * @returns {object} A module object.\n */\nfunction modulePropertiesListToObject(properties, typeRegex) {\n  const keys = Object.keys(properties);\n  const result = {};\n  for (const key of keys) {\n    const modules = [];\n    for (const mod of properties[key]) {\n      const module = modulePropertiesToObject(mod, typeRegex);\n      if (module) {\n        modules.push(module);\n      }\n    }\n    if (modules.length !== 0) {\n      result[key] = modules;\n    }\n  }\n  return result;\n}\n\n/**\n * Objectify modules properties.\n *\n * @param {Array} properties The module properties.\n * @param {string} typeRegex Optional type selection regex.\n * @returns {object} A module object.\n */\nfunction modulePropertiesToObject(properties, typeRegex) {\n  // check length (then only use the first element of each item)\n  if (properties.length !== 4 && properties.length !== 5) {\n    throw new Error('Not the expected module values size: ' +\n      properties.length);\n  }\n  const module = {\n    name: properties[0][0],\n    tag: properties[1][0],\n    type: properties[2][0]\n  };\n\n  // Type property:\n  // - 1: Required; 1C: Type 1 with condition;\n  // - 2: Required, Empty if Unknown; 2C: Type 2 with condition;\n  // - 3: Optional\n  // https://dicom.nema.org/medical/dicom/current/output/chtml/part05/sect_7.4.html\n  if (module.type !== '1' && module.type !== '1C' &&\n    module.type !== '2' && module.type !== '2C' &&\n    module.type !== '3') {\n    console.warn('Unexpected module type: ' + module.type);\n  }\n\n  // type filter\n  if (typeof typeRegex !== 'undefined' &&\n    module.type.match(typeRegex) === null) {\n    return null;\n  }\n\n  // description\n  let desc = '';\n  for (let i = 0; i < properties[3].length; ++i) {\n    // extract enum\n    const extract0 = extractEnum(properties[3][i]);\n    if (typeof extract0.enum !== 'undefined') {\n      module.enum = extract0.enum;\n    }\n    if (extract0.str.length !== 0) {\n      // extract condition\n      const extract1 = extractCondition(extract0.str);\n      if (typeof extract1.condition !== 'undefined') {\n        module.condition = extract1.condition;\n      }\n      // keep what's left\n      if (extract1.str.length !== 0) {\n        if (i !== 0) {\n          desc += ' ';\n        }\n        desc += extract1.str;\n      }\n    }\n  }\n  module.desc = desc;\n\n  // include\n  if (properties.length === 5) {\n    module.items = [];\n    const subProperties = properties[4];\n    for (const subProps of subProperties) {\n      const subModule = modulePropertiesToObject(subProps, typeRegex);\n      if (subModule) {\n        module.items.push(subModule);\n      }\n    }\n  }\n\n  return module;\n}\n\n/**\n * Adapt tags:\n *   - replace 'x' in groups and elements,\n *   - add GenericGroupLength to groups,\n *   - replace non single VRs.\n *\n * @param {Array} inputTags An array of tags.\n * @returns {Array} The adapted tags as a new array.\n */\nfunction adaptTagsForDwv(inputTags) {\n  // check tags\n  if (!inputTags) {\n    throw new Error('No tags.');\n  }\n  if (inputTags.length === 0) {\n    throw new Error('Empty tags.');\n  }\n\n  /**\n   * Replace 'x's in groups and elements.\n   *\n   * @param {string} str The input string.\n   * @returns {string} The updated string.\n   */\n  function replaceXs(str) {\n    str = str.replace(/xxxxx/g, 'x0004');\n    str = str.replace(/xxxx/g, 'x001');\n    str = str.replace(/xx/g, '00');\n    return str;\n  }\n\n  // clone input\n  const tags = inputTags.slice();\n\n  // list groups\n  const groups = [];\n  for (let t = 0; t < tags.length; ++t) {\n    // replace 'x's\n    tags[t].group = replaceXs(tags[t].group);\n    tags[t].element = replaceXs(tags[t].element);\n    // list groups\n    const grp = tags[t].group;\n    if (!groups.includes(grp)) {\n      groups.push(grp);\n    }\n  }\n\n  // add GenericGroupLength to groups\n  for (const group of groups) {\n    if (group !== '0000' && group !== '0002') {\n      tags.push({\n        group: group,\n        element: '0000',\n        keyword: 'GenericGroupLength',\n        vr: 'UL',\n        vm: '1'\n      });\n    }\n  }\n\n  // sort tags\n  tags.sort(getMultiCompare(['group', 'element']));\n\n  // check VRs\n  for (let i = 0; i < tags.length; ++i) {\n    let vr = tags[i].vr;\n    if (typeof vr !== 'undefined') {\n      if (vr.length !== 2) {\n        if (vr.substring(0, 8) === 'See Note') {\n          // #modif \"See Note\" -> \"NONE\"\n          vr = 'NONE';\n        } else if (vr === 'OB or OW') {\n          // #modif \"OB or OW\" -> \"ox\"\n          vr = 'ox';\n        } else if (vr === 'US or OW') {\n          // #modif \"US or OW\" -> \"xx\"\n          vr = 'xx';\n        } else if (vr === 'US or SS' ||\n          vr === 'US or SS or OW') {\n          // #modif \"US or SS\" or \"US or SS or OW\" -> \"xs\"\n          vr = 'xs';\n        } else {\n          console.warn('Unknown VR: \\'' + vr +\n            '\\' for ' + tags[i].group + ',' + tags[i].element);\n        }\n      }\n    } else {\n      vr = '';\n    }\n    tags[i].vr = vr;\n  }\n\n  return tags;\n}\n\n/**\n * Adapt UIDs:\n *   - replace '&amp;' in name with '&',\n *   - remove comments in name: string after ':'.\n *\n * @param {object} inputUids An list of UIDs.\n * @returns {object} The adapted UIDs as a new list.\n */\nfunction adaptUidsForDwv(inputUids) {\n  const keys = Object.keys(inputUids);\n  for (const key of keys) {\n    let name = inputUids[key];\n    // replace '&amp'\n    if (name.includes('&amp;')) {\n      name = name.replace('&amp;', '&');\n      inputUids[key] = name;\n    }\n    // remove comment\n    if (name.includes(':')) {\n      const pos = name.indexOf(':');\n      inputUids[key] = name.substring(0, pos);\n    }\n  }\n\n  return inputUids;\n}\n\n/**\n * Stringify a tags array.\n *\n * @param {Array} tags The tags array.\n * @returns {string} A stringified version of the input array.\n */\nfunction stringifyTags(tags) {\n  // check tags\n  if (!tags) {\n    throw new Error('No tags.');\n  }\n  if (tags.length === 0) {\n    throw new Error('Empty tags.');\n  }\n\n  // tabulation\n  const tab = '  ';\n  const quote = '\\'';\n  // result text\n  let text = '{\\n';\n\n  let group = '';\n  for (let i = 0; i < tags.length; ++i) {\n    const tag = tags[i];\n    let isFirstOfgroup = false;\n    // start group section\n    if (tag.group !== group) {\n      isFirstOfgroup = true;\n      // close previous\n      if (i !== 0) {\n        text += '\\n' + tab + '},\\n';\n      }\n      // start new\n      group = tag.group;\n      text += tab + quote + tag.group + quote + ': {\\n';\n    }\n\n    // tag\n    let tagText = isFirstOfgroup ? '' : ',\\n';\n    tagText += tab + tab +\n      quote + tag.element + quote + ': [' +\n      quote + tag.vr + quote + ', ' +\n      quote + tag.vm + quote + ', ' +\n      quote + tag.keyword + quote + ']';\n    text += tagText;\n  }\n\n  // last group line\n  text += '\\n' + tab + '}\\n';\n  // last line\n  text += '}\\n';\n\n  return text;\n}\n","// DICOM versions object\n// (only those published with this repo since NEMA does not do CORS...)\nconst dicomVersions = {\n  2016: ['a'],\n  2018: ['a'],\n  2020: ['a'],\n  2022: ['a'],\n};\n\n// Supported DICOM parts\nconst dicomParts = ['03', '05', '06', '07'];\n\n/**\n * Get the list of DICOM standard parts.\n *\n * @returns {Array} An array of parts.\n */\nexport function getDicomParts() {\n  return dicomParts;\n}\n\n/**\n * Get the list of DICOM standard versions.\n *\n * @returns {Array} An array of versions, ordered from most recent to older.\n */\nexport function getDicomVersions() {\n  const keys = Object.keys(dicomVersions);\n  keys.sort(compare);\n  // create version strings\n  const versions = [];\n  for (let i = 0; i < keys.length; ++i) {\n    const majorVersion = keys[i];\n    const minorVersions = dicomVersions[majorVersion];\n    for (let j = 0; j < minorVersions.length; ++j) {\n      versions.push(majorVersion + minorVersions[j]);\n    }\n  }\n  // return\n  return versions;\n}\n\n/**\n * Sort keys.\n *\n * @param {string} a First string.\n * @param {string} b Second string.\n * @returns {number} Negative is a > b.\n */\nfunction compare(a, b) {\n  return parseInt(b, 10) - parseInt(a, 10);\n}\n\n/**\n * Get a list of DICOM versions associated to their resrouce link.\n *\n * @param {string} partNumber The part number as a string.\n * @returns {Array} An array of {xml, html} objects.\n */\nexport function getDicomPartLinks(partNumber) {\n  const versions = getDicomVersions();\n  const links = {};\n  for (let i = 0; i < versions.length; ++i) {\n    links[versions[i]] = {\n      xml: getXmlLink(versions[i], partNumber),\n      html: getHtmlLink(versions[i], partNumber),\n    };\n  }\n  // return\n  return links;\n}\n\n/**\n * Get the xml link to the standard.\n * Links go to github since nema does not publish standard with CORS.\n *\n * @param {string} version The standard version.\n * @param {string} partNumber The standard part number as a string.\n * @returns {string} The full link to the desired file.\n */\nfunction getXmlLink(version, partNumber) {\n  const githubRoot = 'https://raw.githubusercontent.com/ivmartel/dcmStdToJs/main/resources/standard';\n  const partFileName = 'part' + partNumber;\n  return githubRoot + '/' + version + '/' + partFileName + '.xml';\n}\n\n/**\n * Get the html link to the standard.\n *\n * @param {string} version The standard version.\n * @param {string} partNumber The standard part number as a string.\n * @returns {string} The full link to the desired html.\n */\nfunction getHtmlLink(version, partNumber) {\n  const nemaRoot = 'http://dicom.nema.org/medical/dicom';\n  const partFileName = 'part' + partNumber;\n  return nemaRoot + '/' + version + '/output/html/' + partFileName + '.html';\n}\n","import {DicomXMLParser} from './parser.js';\nimport * as nema from './nema.js';\n\n/**\n * GUI classe.\n */\nexport class Gui {\n  /**\n   * Setup the gui: bind parse button.\n   */\n  setup() {\n    document.getElementById('parseButton').addEventListener(\n      'click', onParseButtonClick);\n    document.getElementById('fileupload').addEventListener(\n      'change', onFileuploadChange);\n  }\n\n  /**\n   * DOMContentLoaded handler: update the version select.\n   */\n  onDOMContentLoaded() {\n    updateStandardSelect();\n  }\n}\n\n/**\n * Set the progress of the progressbar.\n *\n * @param {Event} event A progress event.\n */\nfunction setProgress(event) {\n  const progressBar = document.getElementById('progressBar');\n  if (event.lengthComputable) {\n    progressBar.max = event.total;\n    progressBar.value = event.loaded;\n  }\n}\n\n/**\n * Handle file upload change event.\n *\n * @param {Event} event The file upload change event.\n */\nfunction onFileuploadChange(event) {\n  // enable / disable parse button if files were selected\n  const parseButton = document.getElementById('parseButton');\n  if (event.target.files.length !== 0) {\n    parseButton.disabled = false;\n  } else {\n    parseButton.disabled = true;\n  }\n}\n\n/**\n * Handle parse button click event.\n *\n * @param {Event} event The parse button click event.\n */\nfunction onParseButtonClick(event) {\n  const button = event.target;\n\n  // reset progress\n  setProgress({loaded: 0, total: 100, lengthComputable: true});\n\n  // disable button\n  button.disabled = true;\n\n  // clear output zone\n  const outputDiv = document.getElementById('output');\n  outputDiv.innerHTML = '';\n\n  const parser = new DicomXMLParser();\n\n  // parse file if provided, parse link otherwise\n  const fileInputElement = document.getElementById('fileupload');\n  if (fileInputElement.files.length === 1) {\n    const file = fileInputElement.files[0];\n    const reader = new FileReader();\n    reader.onload = function (event) {\n      // enable button\n      button.disabled = false;\n      // show tags\n      const domParser = new DOMParser();\n      const doc = domParser.parseFromString(\n        event.target.result, 'application/xml');\n      try {\n        showResult(parser.parseNode(doc, file.name));\n      } catch (error) {\n        showError(error);\n      }\n    };\n    reader.onprogress = setProgress;\n    reader.onloadend = setProgress;\n    reader.onerror = function () {\n      showError('ERROR while loading data, see log for details...');\n    };\n    reader.readAsText(file);\n  } else {\n    // use selected version or default\n    const dicomVersionsSelect = document.getElementById('dicomVersions');\n    const selectedVersion = dicomVersionsSelect.options[\n      dicomVersionsSelect.selectedIndex\n    ].value;\n    const dicomPartsSelect = document.getElementById('dicomParts');\n    const selectedPart = dicomPartsSelect.options[\n      dicomPartsSelect.selectedIndex\n    ].value;\n\n    const url = nema.getDicomPartLinks(selectedPart)[selectedVersion].xml;\n    const request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.responseType = 'document';\n    request.overrideMimeType('text/xml'); // force xml\n    request.onload = function (event) {\n      // enable button\n      button.disabled = false;\n      // show tags\n      try {\n        showResult(parser.parseNode(event.target.response, url));\n      } catch (error) {\n        showError(error);\n      }\n    };\n    request.onprogress = setProgress;\n    request.onloadend = setProgress;\n    request.onerror = function () {\n      showError('ERROR while retrieving data, see log for details...');\n    };\n    request.send();\n  }\n}\n\n/**\n * Format a parse result into a html element and append it to the 'output' div.\n *\n * @param {Array} result A parse result object array.\n */\nfunction showResult(result) {\n  // append to page as text area\n  if (Array.isArray(result)) {\n    for (let i = 0; i < result.length; ++i) {\n      appendResult('result-' + i, result[i]);\n    }\n  } else {\n    appendResult('result-0', result);\n  }\n}\n\n/**\n * Show an error result.\n *\n * @param {string|Event} error The error to display.\n */\nfunction showError(error) {\n  console.error(error);\n  let message = error;\n  if (typeof error.message !== 'undefined') {\n    message = error.message;\n  }\n  appendResult('error', message);\n}\n\n/**\n * Append a text area to the ouput div.\n *\n * @param {string} name The name of text area.\n * @param {object} content The result content.\n */\nfunction appendResult(name, content) {\n  const div = document.getElementById('output');\n  let contentString = '';\n\n  if (typeof content.name !== 'undefined') {\n    const para = document.createElement('p');\n    let numberOfItems;\n    if (Array.isArray(content.raw)) {\n      numberOfItems = content.raw.length;\n    } else {\n      numberOfItems = Object.keys(content.raw).length;\n    }\n    para.appendChild(document.createTextNode(\n      content.name +\n      ' (' + content.origin +\n      ', ' + numberOfItems + ' items) '\n    ));\n\n    const link = document.createElement('a');\n    link.download = 'result.json';\n    const blob = new Blob([content.data], {type: 'text/plain'});\n    link.href = window.URL.createObjectURL(blob);\n    link.appendChild(document.createTextNode('download'));\n\n    para.appendChild(link);\n    div.appendChild(para);\n\n    contentString = content.data;\n  } else {\n    contentString = content;\n  }\n\n  const area = document.createElement('textarea');\n  area.id = name;\n  area.appendChild(document.createTextNode(contentString));\n  area.spellcheck = false;\n  if (name.includes('error')) {\n    area.className = 'error';\n  } else {\n    area.rows = 20;\n  }\n\n  div.appendChild(area);\n}\n\n/**\n * Update standard select with available standard versions.\n */\nfunction updateStandardSelect() {\n  const versionSelect = document.getElementById('dicomVersions');\n\n  // place holder option\n  let versionOption = document.createElement('option');\n  versionOption.disabled = true;\n  versionOption.selected = true;\n  versionOption.text = 'Select a version';\n  versionOption.value = '';\n  versionSelect.add(versionOption);\n  // version options\n  const versions = nema.getDicomVersions();\n  for (let i = 0; i < versions.length; ++i) {\n    versionOption = document.createElement('option');\n    versionOption.text = versions[i];\n    versionOption.value = versions[i];\n    versionSelect.add(versionOption);\n  }\n\n  const partSelect = document.getElementById('dicomParts');\n\n  // place holder option\n  let partOption = document.createElement('option');\n  partOption.disabled = true;\n  partOption.selected = true;\n  partOption.text = 'Select a part';\n  partOption.value = '';\n  partSelect.add(partOption);\n  // part options\n  const parts = nema.getDicomParts();\n  for (let i = 0; i < parts.length; ++i) {\n    partOption = document.createElement('option');\n    partOption.text = parts[i];\n    partOption.value = parts[i];\n    partSelect.add(partOption);\n  }\n\n  const parseButton = document.getElementById('parseButton');\n\n  // update associated links on select change\n  versionSelect.onchange = function (event) {\n    const part = partSelect[partSelect.selectedIndex].value;\n    if (part !== '') {\n      updateVersionLinks(event.target.value, part);\n      parseButton.disabled = false;\n    }\n  };\n  partSelect.onchange = function (event) {\n    const version = versionSelect[versionSelect.selectedIndex].value;\n    if (version !== '') {\n      updateVersionLinks(version, event.target.value);\n      parseButton.disabled = false;\n    }\n  };\n}\n\n/**\n * Update the version links.\n *\n * @param {string} version The dicom standard version.\n * @param {string} partNumber The standard part number.\n */\nfunction updateVersionLinks(version, partNumber) {\n  const links = nema.getDicomPartLinks(partNumber)[version];\n  // xml standard link\n  const xmlLink = document.createElement('a');\n  xmlLink.href = links.xml;\n  xmlLink.appendChild(document.createTextNode('xml'));\n  // html standard link\n  const htmlLink = document.createElement('a');\n  htmlLink.href = links.html;\n  htmlLink.appendChild(document.createTextNode('html'));\n\n  const versionLinks = document.getElementById('versionLinks');\n  // clear\n  versionLinks.innerHTML = '';\n  // add new links\n  versionLinks.appendChild(document.createTextNode('(dict: '));\n  versionLinks.append(xmlLink);\n  versionLinks.appendChild(document.createTextNode(', '));\n  versionLinks.append(htmlLink);\n  versionLinks.appendChild(document.createTextNode(')'));\n}\n","import {Gui} from './gui.js';\nimport './style.css';\n\n// setup\nconst gui = new Gui();\ngui.setup();\ngui.onDOMContentLoaded();"],"names":["DicomXMLParser","parseNode","partNode","origin","book","querySelector","Error","label","getAttribute","subtitle","prefix","innerHTML","startsWith","endIndex","indexOf","versionStr","substring","length","trim","version","year","parseInt","letter","result","iodList","name","iod","usageRegex","fgModulesProperties","fgLabel","parseModulesFromList","parseModuleListNode","getSelector","modules","modulePropertiesListToObject","push","raw","data","JSON","stringify","parsePs33Node","vrs","tableNode","values","parseTableNode","parseVrTableNode","extractors","stringVrTypeExtractor","octetVrTypeExtractor","intVrTypeExtractor","floatVrTypeExtractor","wordVrTypeExtractor","floatWordVrTypeExtractor","value","vrName","definition","type","extractor","console","log","vrsNames","Object","keys","i","vrsResult","isBefore2019e","xmlid","specialVrs","node","checkNodeCaption","matches","getElementsByTagName","matchAll","match","parseVrCaptionNode","vrVl32s","filter","item","includes","vrVl32Result","charSetVrs","regex","paras","para","parseCharSetVrNode","parsePs35Node","tags36","concat","parseTagsTableNode","tagsResults","stringifyTags","adaptTagsForDwv","uids","parseUidTableNode","uidsResults","adaptUidsForDwv","sops","parsePs36Node","tags37","parsePs37Node","getLinkend","str","extractEnum","start","end","desc","enum","split","extractCondition","reqIndex","gotConditionMatch","condition","slice","replace","getCompare","property","a","b","expectedCaption","properties","nodes","querySelectorAll","parseTrNode","isEqualCheck","captions","text","toLowerCase","warn","trNode","parseTdNode","tdNode","childNodes","nodeType","nodeName","parseVariableListNode","parseContentNode","paraNode","content","attributes","linkend","textContent","cleanString","foundTermsList","listNode","listChilds","entries","entryNode","tags","tag","tagPropertiesToObject","uidType","uid","uidPropertiesToObject","keyword","module","moduleDefinitionPropertiesToObject","list","moduleName","reference","sectNode","parseModuleAttributesNode","macros","fgModules","rows","startSq0","startSq1","row","nodeCaptions","attribute","attributeName","includeCase","subTable","undefined","key","previousAtt","geSplit","group","toString","element","vr","vm","startCol","moduleDef","usage","typeRegex","mod","modulePropertiesToObject","extract0","extract1","items","subProperties","subProps","subModule","inputTags","replaceXs","groups","t","grp","sort","res","inputUids","pos","tab","quote","isFirstOfgroup","tagText","dicomVersions","dicomParts","getDicomVersions","compare","versions","majorVersion","minorVersions","j","getDicomPartLinks","partNumber","links","xml","getXmlLink","html","getHtmlLink","githubRoot","nemaRoot","setProgress","event","progressBar","document","getElementById","lengthComputable","max","total","loaded","onFileuploadChange","parseButton","target","files","disabled","onParseButtonClick","button","parser","fileInputElement","file","reader","FileReader","onload","doc","DOMParser","parseFromString","showResult","error","showError","onprogress","onloadend","onerror","readAsText","dicomVersionsSelect","selectedVersion","options","selectedIndex","dicomPartsSelect","url","nema","request","XMLHttpRequest","open","responseType","overrideMimeType","response","send","Array","isArray","appendResult","message","div","contentString","createElement","numberOfItems","appendChild","createTextNode","link","download","blob","Blob","href","window","URL","createObjectURL","area","id","spellcheck","className","updateVersionLinks","xmlLink","htmlLink","versionLinks","append","gui","setup","addEventListener","onDOMContentLoaded","versionSelect","versionOption","selected","add","partSelect","partOption","parts","onchange","part","updateStandardSelect"],"sourceRoot":""}